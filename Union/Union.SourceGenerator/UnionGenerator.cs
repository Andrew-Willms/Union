using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Union.SourceGenerator;



[Generator]
public class UnionGenerator : IIncrementalGenerator {

	private static readonly string AttributeName = $"global::{typeof(GenerateUnionAttribute).FullName!}";

	public void Initialize(IncrementalGeneratorInitializationContext context) {

		IncrementalValuesProvider<INamedTypeSymbol> classDeclarations = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (syntaxNode, _) => SyntaxFilter(syntaxNode),
				transform: static (syntaxContext, _) => SyntaxToSymbol(syntaxContext))
			.Where(static classDeclarationSyntax => classDeclarationSyntax is not null)!;

		IncrementalValueProvider<(Compilation, ImmutableArray<INamedTypeSymbol>)> unionClasses =
			context.CompilationProvider.Combine(classDeclarations.Collect());

		context.RegisterSourceOutput(unionClasses, Execute);
	}

	private static bool SyntaxFilter(SyntaxNode node) {
		return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
	}

	private static INamedTypeSymbol? SyntaxToSymbol(GeneratorSyntaxContext context) {

		if (context.Node is not ClassDeclarationSyntax classDeclarationSyntax) {
			throw new InvalidOperationException($"{nameof(SyntaxFilter)} should filter out non {nameof(ClassDeclarationSyntax)} nodes.");
		}

		INamedTypeSymbol? typeSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax);

		bool? hasGeneratorAttribute = typeSymbol?
			.GetAttributes()
			.Any(x => string.Equals(x.AttributeClass?.ToQualifiedString(), AttributeName));

		return hasGeneratorAttribute is true ? typeSymbol : null;
	}



	private static void Execute(SourceProductionContext context,
		(Compilation compilation, ImmutableArray<INamedTypeSymbol> classes) source) {

		if (source.classes.IsEmpty) {
			return;
		}

		IEnumerable<INamedTypeSymbol> distinctClasses = source.classes.Distinct();
		List<string> fileNames = new();

		foreach (INamedTypeSymbol typeSymbol in distinctClasses) {

			string? classSource = ProcessClass(typeSymbol, context);

			if (classSource is null) {
				continue;
			}

			string fileName = $"{typeSymbol.ContainingNamespace}_{typeSymbol.Name}";
			int fileNumber = 0;

			while (fileNames.Contains(fileName + fileNumber)) {
				fileNumber++;
			}

			fileName += fileNumber;

			fileNames.Add(fileName);
			context.AddSource($"{fileName}.g.cs", classSource);
		}
	}

	private static string? ProcessClass(INamedTypeSymbol classSymbol, SourceProductionContext context) {

		Location? attributeLocation = classSymbol.Locations.FirstOrDefault() ?? Location.None;

		// todo: remove the requirement that the class can't be nested
		if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default)) {

			DiagnosticDescriptors.CantBeNested.Create(attributeLocation, context, classSymbol);
			return null;
		}

		if (classSymbol.BaseType?.Name is not "Union" || classSymbol.BaseType.ContainingNamespace.ToString() is not "Union") {
			DiagnosticDescriptors.MustInheritFromUnion.Create(attributeLocation, context, classSymbol);
			return null;
		}

		ImmutableArray<ITypeSymbol> typeArguments = classSymbol.BaseType.TypeArguments;

		foreach (ITypeSymbol? typeSymbol in typeArguments) {

			if (typeSymbol.Name == nameof(Object)) {
				DiagnosticDescriptors.ObjectIsOneOfType.Create(attributeLocation, context, classSymbol);
				return null;
			}

			if (typeSymbol.TypeKind is TypeKind.Interface) {
				DiagnosticDescriptors.InterfacesNotAllowed.Create(attributeLocation, context, classSymbol);
				return null;
			}
		}

		return GenerateClassSource(classSymbol, classSymbol.BaseType);
	}

	private static string GenerateClassSource(INamedTypeSymbol classSymbol, INamedTypeSymbol baseClassSymbol) {

		string className = ConcreteName(classSymbol);
		string baseClassName = ConcreteName(baseClassSymbol);

		string implicitOperators = baseClassSymbol.TypeArguments
			.Select(x => $"public static implicit operator {className}({x.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} value) => new(value);")
			.Join("\r\n    \r\n    ");

		return new StringBuilder(
			$$"""
			  // <auto-generated />
			  using Union;
			  
			  #pragma warning disable 1591

			  namespace {{classSymbol.ContainingNamespace.ToDisplayString()}};
			  
			  
			  
			  partial class {{className}} {
			  
			      public {{classSymbol.Name}}({{baseClassName}} value) : base(value) { }
			      
			      {{implicitOperators}}
			      
			  }
			  """).ToString();
	}

	// todo benchmark different ways of building the string
	private static string ConcreteName(INamedTypeSymbol typeSymbol) {

		return typeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

		if (!typeSymbol.TypeArguments.Any()) {
			return typeSymbol.Name;
		}

		StringBuilder stringBuilder = new(typeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat) + "<");

		foreach (ITypeSymbol typeArgument in typeSymbol.TypeArguments) {

			stringBuilder.Append(typeArgument.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
			stringBuilder.Append(", ");
		}

		stringBuilder.Append(">");
		return stringBuilder.ToString();
	}

}



public static class CollectionExtensions {

	public static string Join(this IEnumerable<string> array, string separator) {

		return string.Join(separator, array);
	}

	// todo move to a more appropriate place
	public static string ToQualifiedString(this ISymbol typeSymbol) {
		return typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
	}

}
