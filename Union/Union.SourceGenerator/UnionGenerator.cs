using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Union.SourceGenerator;



[Generator]
public class UnionGenerator : IIncrementalGenerator {

	private static readonly string AttributeNameSpace = typeof(GenerateUnionAttribute).Namespace!;
	private const string AttributeName = nameof(GenerateUnionAttribute)!;

	public void Initialize(IncrementalGeneratorInitializationContext context) {

		IncrementalValuesProvider<INamedTypeSymbol> classDeclarations = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (syntaxNode, _) => IsSyntaxTargetForGeneration(syntaxNode),
				transform: static (syntaxContext, _) => GetSemanticTargetForGeneration(syntaxContext))
			.Where(static classDeclarationSyntax => classDeclarationSyntax is not null)!;

		IncrementalValueProvider<(Compilation, ImmutableArray<INamedTypeSymbol>)> unionClasses =
			context.CompilationProvider.Combine(classDeclarations.Collect());

		context.RegisterSourceOutput(unionClasses, Execute);
	}

	private static bool IsSyntaxTargetForGeneration(SyntaxNode node) {
		return node is ClassDeclarationSyntax { AttributeLists.Count: > 0, BaseList.Types.Count: > 0 } classDeclaration 
		       && classDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword);
	}

	private static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorSyntaxContext context) {

		ClassDeclarationSyntax classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

		INamedTypeSymbol? typeSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax);

		AttributeData ? attributeData = typeSymbol?.GetAttributes().FirstOrDefault(ad => string.Equals(
			ad.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), 
			$"global::{AttributeNameSpace}.{AttributeName}"));

		return attributeData is null ? null : typeSymbol;
	}



	private static void Execute(SourceProductionContext context,
		(Compilation compilation, ImmutableArray<INamedTypeSymbol> classes) source) {

		if (source.classes.IsEmpty) {
			return;
		}

		IEnumerable<INamedTypeSymbol> distinctClasses = source.classes.Distinct();

		foreach (INamedTypeSymbol typeSymbol in distinctClasses) {

			string? classSource = ProcessClass(typeSymbol, context);

			if (classSource is null) {
				continue;
			}

			context.AddSource($"{typeSymbol.ContainingNamespace}_{typeSymbol.Name}.g.cs", classSource);
		}
	}

	private static string? ProcessClass(INamedTypeSymbol classSymbol, SourceProductionContext context) {

		Location? attributeLocation = classSymbol.Locations.FirstOrDefault() ?? Location.None;

		if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default)) {
			CreateDiagnosticError(DiagnosticDescriptors.UnionClassMustBeNestedError);
			return null;
		}

		if (classSymbol.BaseType?.Name is not "Union" || classSymbol.BaseType.ContainingNamespace.ToString() is not "Union") {
			CreateDiagnosticError(DiagnosticDescriptors.UnionClassMustInheritFromUnion);
			return null;
		}

		ImmutableArray<ITypeSymbol> typeArguments = classSymbol.BaseType.TypeArguments;

		foreach (ITypeSymbol? typeSymbol in typeArguments) {

			if (typeSymbol.Name == nameof(Object)) {
				CreateDiagnosticError(DiagnosticDescriptors.ObjectIsOneOfType);
				return null;
			}

			if (typeSymbol.TypeKind is TypeKind.Interface) {
				CreateDiagnosticError(DiagnosticDescriptors.UserDefinedConversionsToOrFromAnInterfaceAreNotAllowed);
				return null;
			}
		}

		return GenerateClassSource(classSymbol, classSymbol.BaseType.TypeParameters, typeArguments);

		void CreateDiagnosticError(DiagnosticDescriptor descriptor) {
			context.ReportDiagnostic(Diagnostic.Create(descriptor, attributeLocation, classSymbol.Name,
				DiagnosticSeverity.Error));
		}
	}

	private static string GenerateClassSource(
		INamedTypeSymbol classSymbol,
		ImmutableArray<ITypeParameterSymbol> typeParameters, 
		ImmutableArray<ITypeSymbol> typeArguments) {
		IEnumerable<(ITypeParameterSymbol param, ITypeSymbol arg)> paramArgPairs = typeParameters.Zip(typeArguments, (param, arg) => (param, arg));

		string unionGenericPart = GetGenericPart(classSymbol);
		string classNameWithGenericTypes = $"{classSymbol.Name}{GetOpenGenericPart(classSymbol)}";

		string implicitOperators = string.Join("\n    \n    ", paramArgPairs.Select(
			x => $"public static implicit operator {classNameWithGenericTypes}" + 
			     $"({x.arg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} _) => new {classNameWithGenericTypes}(_);"));

		return new StringBuilder(
			$$"""
			  // <auto-generated />
			  #pragma warning disable 1591

			  namespace {{classSymbol.ContainingNamespace.ToDisplayString()}};
			  
			  partial class {{classNameWithGenericTypes}} {
			  
			      public {{classSymbol.Name}}(Union.Union<{{unionGenericPart}}> _) : base(_) { }
			      
			      {{implicitOperators}}
			      
			  }
			  """).ToString();
	}

	// todo: move out to separate library
	private static string? GetOpenGenericPart(INamedTypeSymbol classSymbol) {

		return classSymbol.TypeArguments.Any()
			? $"<{GetGenericPart(classSymbol)}>" 
			: null;
	}

	// todo: move out to separate library
	private static string GetGenericPart(INamedTypeSymbol classSymbol) {

		return string.Join(", ", classSymbol.TypeArguments.Select(x => x.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));
	}

}